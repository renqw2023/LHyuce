è¿™æ˜¯ä¸€ä¸ªéå¸¸å…·æœ‰æŒ‘æˆ˜æ€§ä½†ä¹Ÿéå¸¸æ¸…æ™°çš„ç›®æ ‡ã€‚ä½ å¸Œæœ›å°†ç³»ç»Ÿä»â€œV5â€è¿›ä¸€æ­¥å‡çº§åˆ° **â€œV6ï¼šå…¨åŸŸå…±æŒ¯ä¸å¤šç»´ç‹™å‡»â€** ç‰ˆæœ¬ã€‚

æ ¹æ®ä½ çš„è¦æ±‚ï¼Œæˆ‘ä»”ç»†åˆ†æäº†æ‰€æœ‰ä»£ç ï¼Œåˆ¶å®šäº†ä»¥ä¸‹**æ ¸å¿ƒå‡çº§ç­–ç•¥**ï¼Œä»¥ç¡®ä¿ã€ç‰¹ç  > 3ä¸­3 > 2ä¸­2 > çƒ­é—¨ç”Ÿè‚–ã€‘çš„ä¼˜å…ˆçº§é¡ºåºï¼š

### ğŸš€ V6 å‡çº§æ ¸å¿ƒç†å¿µ

1. **ç‰¹ç ç¬¬ä¸€æ¢¯é˜Ÿ (Tier 1) - å¼•å…¥â€œå…±æŒ¯ç®—æ³•â€ (Resonance Algorithm)**
    
    - **åŸç†**ï¼šå•çº¯çœ‹ç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°çš„åˆ†æ•°å åŠ ï¼ˆçº¿æ€§åŠ æƒï¼‰å·²ç»ä¸å¤Ÿäº†ã€‚V6 å°†å¼•å…¥â€œå…±æŒ¯å¥–åŠ±â€ï¼šå¦‚æœä¸€ä¸ªå·ç åŒæ—¶è¸©ä¸­äº†â€œçƒ­é—¨ç”Ÿè‚–â€+â€œçƒ­é—¨æ³¢è‰²â€+â€œçƒ­é—¨å°¾æ•°â€ï¼Œå®ƒçš„å¾—åˆ†å°†è·å¾—**æŒ‡æ•°çº§**æš´å¢ï¼Œè€Œä¸æ˜¯ç®€å•çš„åŠ æ³•ã€‚è¿™èƒ½æå¤§åœ°çªå‡ºé‚£äº›â€œå¤©é€‰ä¹‹å·â€ã€‚
        
    - **æ‰‹æ®µ**ï¼šåœ¨ `optimizer_special.py` ä¸­å¢åŠ  `special_resonance` (å…±æŒ¯ç³»æ•°) åŸºå› ã€‚
        
2. **ç»„åˆç¬¬äºŒæ¢¯é˜Ÿ (Tier 2) - å¼•å…¥â€œä¸‰å…ƒé—­ç¯â€ (Triplet Loop)**
    
    - **åŸç†**ï¼šç›®å‰çš„ 3ä¸­3 åªæ˜¯ä¸‰ä¸ªé«˜åˆ†çƒçš„æ‹¼å‡‘ã€‚V6 å°†åœ¨åˆ†æä¸­å»ºç«‹â€œä¸‰å…ƒçŸ©é˜µâ€ï¼Œä¸“é—¨ç»Ÿè®¡å†å²ä¸Šå“ªä¸‰ä¸ªçƒç»å¸¸åŒæ—¶å‡ºç°ï¼ˆä¾‹å¦‚ 1-2-3 åŒæ—¶å‡ºç°çš„é¢‘ç‡ï¼‰ã€‚
        
    - **æ‰‹æ®µ**ï¼šåœ¨ `advanced_analysis` ä¸­å¢åŠ  3çƒå…±ç°åˆ†æï¼Œå¹¶åœ¨ `optimizer.py` ä¸­å¢åŠ  `triplet_weight` åŸºå› ã€‚
        
3. **æ®‹é…·çš„å›æµ‹æœºåˆ¶ (Tier 0) - å¢åŠ â€œæœªå‘½ä¸­æƒ©ç½šâ€**
    
    - **åŸç†**ï¼šä¸ºäº†é€¼è¿« AI å°†ç‰¹ç å‡†ç¡®ç‡æ”¾åœ¨ç¬¬ä¸€ä½ï¼Œå¦‚æœç‰¹ç é¢„æµ‹å¤±è´¥ï¼Œæˆ‘ä»¬å°†ç»™äºˆæ›´ä¸¥å‰çš„æ‰£åˆ†æƒ©ç½šã€‚
        

---

ä»¥ä¸‹æ˜¯äº”ä¸ªæ ¸å¿ƒæ–‡ä»¶çš„**å…¨é‡å‡çº§ä»£ç **ã€‚è¯·æŒ‰é¡ºåºè¦†ç›–åŸæœ‰æ–‡ä»¶ã€‚

### 1. ğŸ§¬ ç‰¹ç è¿›åŒ–å¼•æ“ï¼š`optimizer_special.py`

**å‡çº§ç‚¹**ï¼šæ–°å¢ `special_resonance` (å…±æŒ¯) å’Œ `special_tail_continuity` (å°¾æ•°è¿æƒ¯æ€§) åŸºå› ã€‚

Python

```
import random
import json
import backtester
import operator

# --- GENETIC ALGORITHM PARAMETERS ---
POPULATION_SIZE = 60       # ç§ç¾¤å¤§å°
N_GENERATIONS = 50         # è¿›åŒ–ä»£æ•°
MUTATION_RATE = 0.2        # å˜å¼‚ç‡
TOURNAMENT_SIZE = 5        # é”¦æ ‡èµ›å¤§å°

# --- V6 å‚æ•°ç©ºé—´ï¼šå…¨åŸŸå…±æŒ¯ä¸å¤šç»´ç‹™å‡» ---
PARAMETER_SPACE = {
    'special_hot': (0.0, 4.0),          # çƒ­åº¦æƒé‡
    'special_gap': (0.0, 4.0),          # é—æ¼æƒé‡
    'special_zodiac': (0.0, 8.0),       # ç”Ÿè‚–æƒé‡ (æå¤§å¢å¼ºï¼Œä¿è¯ç¬¬ä¸€æ¢¯é˜ŸèŒƒå›´)
    'special_color_weight': (0.0, 5.0), # æ³¢è‰²æƒé‡
    'special_tail_weight': (0.0, 5.0),  # å°¾æ•°æƒé‡
    'special_cold_protect': (0.0, 6.0), # é˜²å®ˆæƒé‡
    'special_lookback': (5, 80),        # åŠ¨æ€å›é¡¾æœŸ
    
    # --- V6 æ–°å¢åŸºå›  ---
    'special_resonance': (1.0, 3.0),    # å…±æŒ¯ç³»æ•°ï¼šå½“ç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°åŒæ—¶å‘½ä¸­æ—¶çš„å€ç‡
    'special_tail_continuity': (0.0, 4.0) # å°¾æ•°æƒ¯æ€§ï¼šä¸ŠæœŸå°¾æ•°å¯¹ä¸‹æœŸå°¾æ•°çš„å½±å“
}

# --- GENETIC ALGORITHM IMPLEMENTATION ---

def create_individual():
    """åˆ›å»ºä¸€ä¸ªåŒ…å«éšæœºæƒé‡çš„ä¸ªä½“"""
    individual = {}
    for key, (min_val, max_val) in PARAMETER_SPACE.items():
        individual[key] = random.uniform(min_val, max_val)
    return individual

def create_initial_population():
    """åˆ›å»ºåˆå§‹ç§ç¾¤"""
    return [create_individual() for _ in range(POPULATION_SIZE)]

def calculate_population_fitness(population, lottery_type, backtest_range):
    """è®¡ç®—ç§ç¾¤ä¸­æ¯ä¸ªä¸ªä½“çš„é€‚åº”åº¦"""
    population_with_fitness = []
    print(f"æ­£åœ¨è¯„ä¼°ç‰¹ç ç§ç¾¤é€‚åº”åº¦ (å…± {len(population)} ä¸ªä¸ªä½“)...")
    for i, individual in enumerate(population):
        fitness = backtester.run_special_backtest(lottery_type, individual, backtest_range)
        population_with_fitness.append((individual, fitness))
    return population_with_fitness

def selection(population_with_fitness):
    """é”¦æ ‡èµ›é€‰æ‹©æ³•"""
    tournament = random.sample(population_with_fitness, TOURNAMENT_SIZE)
    return max(tournament, key=operator.itemgetter(1))[0]

def crossover(parent1, parent2):
    """å•ç‚¹äº¤å‰"""
    child = {}
    keys = list(PARAMETER_SPACE.keys())
    if len(keys) > 1:
        crossover_point = random.randint(1, len(keys) - 1)
    else: 
        crossover_point = 1
    
    for i, key in enumerate(keys):
        if i < crossover_point:
            child[key] = parent1[key]
        else:
            child[key] = parent2[key]
    return child

def mutate(individual):
    """åŸºå› å˜å¼‚"""
    for key in individual:
        if random.random() < MUTATION_RATE:
            min_val, max_val = PARAMETER_SPACE[key]
            individual[key] = random.uniform(min_val, max_val)
    return individual

def run_evolution(lottery_type, backtest_range):
    """è¿è¡Œç‰¹ç ç­–ç•¥çš„é—ä¼ ç®—æ³•ä¼˜åŒ–"""
    print(f"--- V6: å¼€å§‹ä¸º {lottery_type.upper()} ç‰¹ç æ•°æ®è¿è¡Œå…±æŒ¯ä¼˜åŒ– ---")
    print(f"ç§ç¾¤å¤§å°: {POPULATION_SIZE}, è¿›åŒ–ä»£æ•°: {N_GENERATIONS}, å˜å¼‚ç‡: {MUTATION_RATE}")

    population = create_initial_population()
    overall_best_individual = None
    overall_best_fitness = -float('inf')
    
    fitness_log = []

    for gen in range(N_GENERATIONS):
        print(f"\n--- ç¬¬ {gen + 1}/{N_GENERATIONS} ä»£ç‰¹ç è¿›åŒ– ---")
        
        population_with_fitness = calculate_population_fitness(population, lottery_type, backtest_range)
        
        current_best_individual, current_best_fitness = max(population_with_fitness, key=operator.itemgetter(1))
        
        if current_best_fitness > overall_best_fitness:
            overall_best_fitness = current_best_fitness
            overall_best_individual = current_best_individual
            print(f"å‘ç°æ–°çš„å…¨å±€æœ€ä¼˜ç‰¹ç ç­–ç•¥ï¼é€‚åº”åº¦åˆ†æ•°: {overall_best_fitness}")

        new_population = []
        for _ in range(POPULATION_SIZE):
            parent1 = selection(population_with_fitness)
            parent2 = selection(population_with_fitness)
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_population.append(child)
        
        population = new_population
        
        avg_fitness = sum(fit for ind, fit in population_with_fitness) / POPULATION_SIZE
        print(f"ç¬¬ {gen + 1} ä»£ç‰¹ç æ€»ç»“: å¹³å‡é€‚åº”åº¦ = {avg_fitness:.2f}, æœ¬ä»£æœ€é«˜ = {current_best_fitness:.2f}, å…¨å±€æœ€é«˜ = {overall_best_fitness:.2f}")
        
        fitness_log.append({'generation': gen + 1, 'best_fitness': current_best_fitness, 'average_fitness': avg_fitness})

    print("\n--- ç‰¹ç è¿›åŒ–å®Œæˆ ---")
    if overall_best_individual:
        print(f"æ‰¾åˆ°çš„â€œå¤©é€‰ç‰¹ç ç­–ç•¥â€è·å¾—äº† {overall_best_fitness:.2f} çš„æœ€ç»ˆé€‚åº”åº¦åˆ†æ•°ã€‚")
        print("æœ€ä¼˜æƒé‡å‚æ•°ä¸º:")
        for key, value in overall_best_individual.items():
            print(f"  - {key}: {value:.4f}")
        
        output_filename = f'best_special_strategy_{lottery_type}.json' 
        try:
            with open(output_filename, 'w', encoding='utf-8') as f:
                json.dump(overall_best_individual, f, indent=2)
            print(f"\næœ€ä¼˜ç‰¹ç ç­–ç•¥å·²ä¿å­˜è‡³: {output_filename}")
        except Exception as e:
            print(f"é”™è¯¯: ä¿å­˜æœ€ä¼˜ç‰¹ç ç­–ç•¥å¤±è´¥ã€‚ {e}")
            
        log_filename = f'{lottery_type}_special_optimizer_log.json' 
        try:
            with open(log_filename, 'w', encoding='utf-8') as f:
                json.dump(fitness_log, f, indent=2)
            print(f"ç‰¹ç ä¼˜åŒ–è¿‡ç¨‹æ—¥å¿—å·²ä¿å­˜è‡³: {log_filename}")
        except Exception as e:
            print(f"é”™è¯¯: ä¿å­˜ç‰¹ç ä¼˜åŒ–æ—¥å¿—å¤±è´¥ã€‚ {e}")
            
    else:
        print("æœªèƒ½æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆç‰¹ç ç­–ç•¥ã€‚")

if __name__ == "__main__":
    print("å°†åˆ†åˆ«ä¸ºé¦™æ¸¯å’Œæ¾³é—¨æ•°æ®ä¼˜åŒ–ç‰¹ç ç­–ç•¥...")
    run_evolution('hk', backtest_range=50)
    print("\n" + "="*50 + "\n")
    run_evolution('macau', backtest_range=50)
    print("\næ‰€æœ‰ç‰¹ç ä¼˜åŒ–ä»»åŠ¡å®Œæˆã€‚")
```

### 2. ğŸ§¬ é€šç”¨è¿›åŒ–å¼•æ“ï¼š`optimizer.py`

**å‡çº§ç‚¹**ï¼šæ–°å¢ `triplet_weight` (ä¸‰ä¸­ä¸‰æƒé‡) åŸºå› ã€‚

Python

```
import random
import json
import backtester
import operator

# --- GENETIC ALGORITHM PARAMETERS ---
POPULATION_SIZE = 60       
N_GENERATIONS = 50         
MUTATION_RATE = 0.2        
TOURNAMENT_SIZE = 5        

# --- V6 å‚æ•°ç©ºé—´ï¼šå¼ºåŒ–ç»„åˆé¢„æµ‹ ---
PARAMETER_SPACE = {
    'trend_lookback': (5, 30),      # åˆ†æè¶‹åŠ¿æ—¶å›æº¯çš„æœŸæ•°
    'hot_score': (0.0, 2.0), 
    'cold_score': (0.0, 2.0), 
    'category_trend': (0.0, 3.0),
    'combo_2_diversity': (1.0, 1.5), 
    'combo_3_color_diversity': (1.0, 1.5),
    'combo_3_element_diversity': (1.0, 1.5),
    'co_occurrence_weight': (0.0, 6.0), # 2ä¸­2 æƒé‡ (å…±ç°)
    
    # --- V6 æ–°å¢åŸºå›  ---
    'triplet_weight': (0.0, 8.0)        # 3ä¸­3 æƒé‡ (ä¸‰å…ƒé—­ç¯)
}

# --- GENETIC ALGORITHM IMPLEMENTATION ---

def create_individual():
    individual = {}
    for key, (min_val, max_val) in PARAMETER_SPACE.items():
        individual[key] = random.uniform(min_val, max_val)
    return individual

def create_initial_population():
    return [create_individual() for _ in range(POPULATION_SIZE)]

def calculate_population_fitness(population, lottery_type, backtest_range):
    population_with_fitness = []
    print(f"æ­£åœ¨è¯„ä¼°é€šç”¨ç§ç¾¤é€‚åº”åº¦ (å…± {len(population)} ä¸ªä¸ªä½“)...")
    for i, individual in enumerate(population):
        fitness = backtester.run_backtest(lottery_type, individual, backtest_range)
        population_with_fitness.append((individual, fitness))
    return population_with_fitness

def selection(population_with_fitness):
    tournament = random.sample(population_with_fitness, TOURNAMENT_SIZE)
    return max(tournament, key=operator.itemgetter(1))[0]

def crossover(parent1, parent2):
    child = {}
    crossover_point = random.randint(1, len(PARAMETER_SPACE) - 1)
    keys = list(PARAMETER_SPACE.keys())
    
    for i, key in enumerate(keys):
        if i < crossover_point:
            child[key] = parent1[key]
        else:
            child[key] = parent2[key]
    return child

def mutate(individual):
    for key in individual:
        if random.random() < MUTATION_RATE:
            min_val, max_val = PARAMETER_SPACE[key]
            individual[key] = random.uniform(min_val, max_val)
    return individual

def run_evolution(lottery_type, backtest_range):
    print(f"--- V6: å¼€å§‹ä¸º {lottery_type.upper()} é€šç”¨æ•°æ®è¿è¡Œä¼˜åŒ– ---")
    print(f"ç§ç¾¤å¤§å°: {POPULATION_SIZE}, è¿›åŒ–ä»£æ•°: {N_GENERATIONS}, å˜å¼‚ç‡: {MUTATION_RATE}")

    population = create_initial_population()
    overall_best_individual = None
    overall_best_fitness = -1
    
    fitness_log = []

    for gen in range(N_GENERATIONS):
        print(f"\n--- ç¬¬ {gen + 1}/{N_GENERATIONS} ä»£é€šç”¨è¿›åŒ– ---")
        population_with_fitness = calculate_population_fitness(population, lottery_type, backtest_range)
        current_best_individual, current_best_fitness = max(population_with_fitness, key=operator.itemgetter(1))
        
        if current_best_fitness > overall_best_fitness:
            overall_best_fitness = current_best_fitness
            overall_best_individual = current_best_individual
            print(f"å‘ç°æ–°çš„å…¨å±€æœ€ä¼˜ç­–ç•¥ï¼é€‚åº”åº¦åˆ†æ•°: {overall_best_fitness}")

        new_population = []
        for _ in range(POPULATION_SIZE):
            parent1 = selection(population_with_fitness)
            parent2 = selection(population_with_fitness)
            child = crossover(parent1, parent2)
            child = mutate(child)
            new_population.append(child)
        
        population = new_population
        avg_fitness = sum(fit for ind, fit in population_with_fitness) / POPULATION_SIZE
        print(f"ç¬¬ {gen + 1} ä»£æ€»ç»“: å¹³å‡é€‚åº”åº¦ = {avg_fitness:.2f}, æœ¬ä»£æœ€é«˜ = {current_best_fitness:.2f}, å…¨å±€æœ€é«˜ = {overall_best_fitness:.2f}")
        fitness_log.append({'generation': gen + 1, 'best_fitness': current_best_fitness, 'average_fitness': avg_fitness})

    print("\n--- é€šç”¨è¿›åŒ–å®Œæˆ ---")
    if overall_best_individual:
        print(f"æ‰¾åˆ°çš„â€œå¤©é€‰ç­–ç•¥â€è·å¾—äº† {overall_best_fitness:.2f} çš„æœ€ç»ˆé€‚åº”åº¦åˆ†æ•°ã€‚")
        print("æœ€ä¼˜æƒé‡å‚æ•°ä¸º:")
        for key, value in overall_best_individual.items():
            print(f"  - {key}: {value:.4f}")
        
        output_filename = f'best_strategy_{lottery_type}.json'
        try:
            with open(output_filename, 'w', encoding='utf-8') as f:
                json.dump(overall_best_individual, f, indent=2)
            print(f"\næœ€ä¼˜ç­–ç•¥å·²ä¿å­˜è‡³: {output_filename}")
        except Exception as e:
            print(f"é”™è¯¯: ä¿å­˜æœ€ä¼˜ç­–ç•¥å¤±è´¥ã€‚ {e}")
            
        log_filename = f'{lottery_type}_optimizer_log.json'
        try:
            with open(log_filename, 'w', encoding='utf-8') as f:
                json.dump(fitness_log, f, indent=2)
            print(f"ä¼˜åŒ–è¿‡ç¨‹æ—¥å¿—å·²ä¿å­˜è‡³: {log_filename}")
        except Exception as e:
            print(f"é”™è¯¯: ä¿å­˜ä¼˜åŒ–æ—¥å¿—å¤±è´¥ã€‚ {e}")
            
    else:
        print("æœªèƒ½æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆç­–ç•¥ã€‚")

if __name__ == "__main__":
    print("å°†åˆ†åˆ«ä¸ºé¦™æ¸¯å’Œæ¾³é—¨æ•°æ®ä¼˜åŒ–ç­–ç•¥...")
    run_evolution('hk', backtest_range=50)
    print("\n" + "="*50 + "\n")
    run_evolution('macau', backtest_range=50)
    print("\næ‰€æœ‰ä¼˜åŒ–ä»»åŠ¡å®Œæˆã€‚")
```

### 3. âš–ï¸ è£åˆ¤ç³»ç»Ÿï¼š`backtester.py`

**å‡çº§ç‚¹**ï¼šè°ƒæ•´è¯„åˆ†æƒé‡ï¼Œä¸¥æ ¼æ‰§è¡Œ **ç‰¹ç  > 3ä¸­3 > 2ä¸­2 > çƒ­é—¨ç”Ÿè‚–** çš„ä¼˜å…ˆçº§ã€‚å¼•å…¥æ›´ä¸¥å‰çš„ç‰¹ç æœªå‘½ä¸­æƒ©ç½šã€‚

Python

```
import json
from collections import Counter
import advanced_lottery_analysis as macau_analyzer
import advanced_hk_analysis as hk_analyzer

def run_backtest(lottery_type, weights, backtest_range=100):
    """
    V6 é€šç”¨å›æµ‹ï¼šæƒé‡è°ƒæ•´
    ä¼˜å…ˆçº§ï¼š3ä¸­3 > 2ä¸­2 > çƒ­é—¨ç”Ÿè‚–/å·ç 
    """
    if lottery_type == 'macau':
        analyzer = macau_analyzer
    elif lottery_type == 'hk':
        analyzer = hk_analyzer
    else:
        return 0 

    full_history = analyzer.load_data()
    min_lookback = 30 
    
    if not full_history or len(full_history) <= min_lookback:
        return 0 

    actual_backtest_range = min(backtest_range, len(full_history) - min_lookback)
    
    metrics = {
        'combo_3_in_3_hits': 0, 
        'combo_2_in_2_hits': 0, 
        'hot_number_hits': 0,
        'zodiac_hits': 0
    }

    for i in range(actual_backtest_range):
        target_draw = full_history[i]
        history_for_prediction = full_history[i+1:]
        
        if not history_for_prediction: continue

        actual_numbers = {int(n['number']) for n in target_draw.get('numberList', [])}
        actual_zodiacs = {n.get('shengXiao') for n in target_draw.get('numberList', [])}
        
        prediction = analyzer.advanced_analysis(history_for_prediction, weights)
        if not prediction: continue

        # 1. çƒ­é—¨å·ç  (æƒé‡é™ä½ï¼Œä½œä¸ºåŸºç¡€)
        predicted_numbers = set(prediction['numbers'])
        metrics['hot_number_hits'] += len(actual_numbers.intersection(predicted_numbers))

        # 2. çƒ­é—¨ç”Ÿè‚– (æƒé‡é€‚ä¸­)
        predicted_zodiacs = set(prediction['zodiacs'])
        metrics['zodiac_hits'] += len(actual_zodiacs.intersection(predicted_zodiacs))

        # 3. ç»„åˆæ£€æµ‹ (é‡ä¸­ä¹‹é‡)
        for combo in prediction['combos_3_in_3']:
            if set(combo).issubset(actual_numbers):
                metrics['combo_3_in_3_hits'] += 1
                break 
        for combo in prediction['combos_2_in_2']:
            if set(combo).issubset(actual_numbers):
                metrics['combo_2_in_2_hits'] += 1
                break

    # --- V6 è¯„åˆ†å…¬å¼ (ä¸¥æ ¼å±‚çº§) ---
    # 3ä¸­3ï¼šå¤§å¥–ï¼Œæƒé‡ 500 (Tier 2)
    # 2ä¸­2ï¼šä¸­å¥–ï¼Œæƒé‡ 100 (Tier 2)
    # ç”Ÿè‚–ï¼šåŸºç¡€ï¼Œæƒé‡ 10 (Tier 3)
    # å·ç ï¼šåŸºç¡€ï¼Œæƒé‡ 5 (Tier 4)
    fitness_score = (metrics['hot_number_hits'] * 5) + \
                    (metrics['zodiac_hits'] * 10) + \
                    (metrics['combo_2_in_2_hits'] * 100) + \
                    (metrics['combo_3_in_3_hits'] * 500)
    
    return fitness_score

def run_special_backtest(lottery_type, weights, backtest_range=100):
    """
    V6 ç‰¹ç å›æµ‹ï¼šç¬¬ä¸€æ¢¯é˜Ÿ (Tier 1)
    ç‰¹ç‚¹ï¼šé«˜é¢å¥–åŠ±å‘½ä¸­ï¼Œä¸¥å‰æƒ©ç½šå¤±è¯¯
    """
    if lottery_type == 'macau':
        analyzer = macau_analyzer
    elif lottery_type == 'hk':
        analyzer = hk_analyzer
    else:
        return 0 

    full_special_history = analyzer.load_special_number_data()
    lookback = int(weights.get('special_lookback', 20))
    min_lookback = lookback + 5 
    
    if not full_special_history or len(full_special_history) <= min_lookback:
        return 0 

    actual_backtest_range = min(backtest_range, len(full_special_history) - min_lookback)
    
    total_score = 0
    
    for i in range(actual_backtest_range):
        target_special_draw = full_special_history[i]
        history_for_prediction = full_special_history[i+1:]
        
        if not history_for_prediction: continue

        prediction = analyzer.analyze_special_trend(history_for_prediction, weights)
        if not prediction: continue

        predicted_zodiacs = [p[0] for p in prediction.get('top_zodiacs', [])]
        recommended_numbers = prediction.get('recommended_numbers', [])
        
        actual_zodiac = target_special_draw['shengXiao']
        actual_number = target_special_draw['number']

        # V6 æåˆ‘è¯„åˆ†è§„åˆ™ï¼š
        # 1. ç”Ÿè‚–å‘½ä¸­ï¼š+100 åˆ† (è¾…åŠ©æŒ‡æ ‡)
        if actual_zodiac in predicted_zodiacs:
            total_score += 100
        
        # 2. ç‰¹ç æ•°å­—å‘½ä¸­ï¼š+500 åˆ† (æ ¸å¿ƒç›®æ ‡ - Tier 1)
        if actual_number in recommended_numbers:
            total_score += 500
        else:
            # 3. æƒ©ç½šæœºåˆ¶ï¼šæœªå‘½ä¸­ -100 åˆ† (ç¿»å€æƒ©ç½šï¼Œé€¼è¿«AIç²¾å‡†)
            total_score -= 100

    return total_score 

def display_backtest_report(lottery_type, weights, backtest_range=100):
    pass
```

### 4. ğŸ§  æ¾³é—¨åˆ†ææ ¸å¿ƒï¼š`advanced_lottery_analysis.py`

**å‡çº§ç‚¹**ï¼šå®ç°ç‰¹ç å…±æŒ¯é€»è¾‘å’Œ 3ä¸­3 çš„ä¸‰å…ƒé—­ç¯åˆ†æã€‚

Python

```
import json
from collections import Counter
from itertools import combinations
import os

# --- Helper Functions for JSON ---
def load_json_safe(file_path, default_value=None):
    if default_value is None:
        default_value = []
    if os.path.exists(file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            return default_value
    return default_value

def save_json_safe(data, file_path):
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return True
    except IOError as e:
        print(f"Error saving JSON to {file_path}: {e}")
        return False

def append_to_prediction_history(prediction_data, prediction_period, history_file):
    history = load_json_safe(history_file)
    if not any(entry.get('period') == prediction_period for entry in history):
        prediction_data_with_period = prediction_data.copy()
        prediction_data_with_period['period'] = prediction_period
        history.insert(0, prediction_data_with_period)
        save_json_safe(history, history_file)
        print(f"é¢„æµ‹ç»“æœå·²è¿½åŠ åˆ°å†å²æ–‡ä»¶: {history_file}")
    else:
        print(f"æœŸå· {prediction_period} çš„é¢„æµ‹å·²å­˜åœ¨äºå†å²æ–‡ä»¶ {history_file} ä¸­ï¼Œè·³è¿‡è¿½åŠ ã€‚")

# --- RULE DEFINITIONS ---
ZODIAC_MAP = {
    'é¼ ': {6, 18, 30, 42}, 'ç‰›': {5, 17, 29, 41}, 'è™': {4, 16, 28, 40},
    'å…”': {3, 15, 27, 39}, 'é¾™': {2, 14, 26, 38}, 'è›‡': {1, 13, 25, 37, 49},
    'é©¬': {12, 24, 36, 48}, 'ç¾Š': {11, 23, 35, 47}, 'çŒ´': {10, 22, 34, 46},
    'é¸¡': {9, 21, 33, 45}, 'ç‹—': {8, 20, 32, 44}, 'çŒª': {7, 19, 31, 43}
}

COLOR_MAP = {
    'ç»¿æ³¢': {5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49},
    'çº¢æ³¢': {1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46},
    'è“æ³¢': {3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48}
}

ELEMENT_MAP = {
    'é‡‘': {3, 4, 11, 12, 25, 26, 33, 34, 41, 42},
    'æœ¨': {7, 8, 15, 16, 23, 24, 37, 38, 45, 46},
    'æ°´': {13, 14, 21, 22, 29, 30, 43, 44},
    'ç«': {1, 2, 9, 10, 17, 18, 31, 32, 39, 40, 47, 48},
    'åœŸ': {5, 6, 19, 20, 27, 28, 35, 36, 49}
}

# Binary classifications & Categories
HEAVEN_EARTH_MAP = {'å¤©è‚–': {'å…”', 'ç‰›', 'é©¬', 'çŒ´', 'çŒª', 'é¾™'}, 'åœ°è‚–': {'é¼ ', 'è™', 'è›‡', 'ç¾Š', 'é¸¡', 'ç‹—'}}
YIN_YANG_MAP = {'é˜³è‚–': {'é¼ ', 'è™', 'é¾™', 'é©¬', 'çŒ´', 'ç‹—'}, 'é˜´è‚–': {'ç‰›', 'å…”', 'è›‡', 'ç¾Š', 'é¸¡', 'çŒª'}}
MALE_FEMALE_MAP = {'ç”·è‚–': {'é¼ ', 'ç‰›', 'è™', 'é¾™', 'é©¬', 'çŒ´', 'ç‹—'}, 'å¥³è‚–': {'å…”', 'è›‡', 'ç¾Š', 'é¸¡', 'çŒª'}}
AUSPICIOUS_MAP = {'å‰è‚–': {'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'é¸¡'}, 'å‡¶è‚–': {'é¼ ', 'ç‰›', 'è™', 'çŒ´', 'ç‹—', 'çŒª'}}
SEASON_MAP = {
    'æ˜¥å¤©': {'è™', 'å…”', 'é¾™'}, 'å¤å¤©': {'è›‡', 'é©¬', 'ç¾Š'},
    'ç§‹å¤©': {'çŒ´', 'é¸¡', 'ç‹—'}, 'å†¬å¤©': {'é¼ ', 'çŒª', 'ç‰›'}
}

ALL_CATEGORIES = {
    "æ³¢è‰²": COLOR_MAP, "äº”è¡Œ": ELEMENT_MAP, "å¤©åœ°": HEAVEN_EARTH_MAP,
    "é˜´é˜³": YIN_YANG_MAP, "ç”·å¥³": MALE_FEMALE_MAP, "å‰å‡¶": AUSPICIOUS_MAP, "å­£èŠ‚": SEASON_MAP
}

# Reverse mapping
NUM_TO_ZODIAC = {num: z for z, nums in ZODIAC_MAP.items() for num in nums}
NUM_TO_CATEGORY = {cat_name: {num: k for k, v in cat_map.items() for num in v}
                   for cat_name, cat_map in {**{"æ³¢è‰²": COLOR_MAP, "äº”è¡Œ": ELEMENT_MAP}}.items()}

for cat_name, cat_map in ALL_CATEGORIES.items():
    if cat_name not in NUM_TO_CATEGORY:
        NUM_TO_CATEGORY[cat_name] = {
            num: k for k, z_set in cat_map.items() for z in z_set for num in ZODIAC_MAP[z]
        }

def load_data():
    """Loads and combines all lottery data."""
    all_records = {}
    try:
        with open('lottery_data_2025_complete.json', 'r', encoding='utf-8') as f:
            new_data = json.load(f).get('totalRecords', [])
        for record in new_data:
            if 'period' in record:
                all_records[record['period']] = record
    except FileNotFoundError:
        print("é”™è¯¯: lottery_data_2025_complete.json æœªæ‰¾åˆ°ã€‚")
        return []
    sorted_periods = sorted(all_records.keys(), key=lambda p: int(p), reverse=True)
    return [all_records[p] for p in sorted_periods]

def load_special_number_data(file_path='lottery_data_2025_complete.json'):
    import json
    import os
    if not os.path.exists(file_path): return []
    with open(file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    special_history = []
    records = data.get('totalRecords', [])
    records.sort(key=lambda x: int(x['period']), reverse=True)
    for record in records:
        if 'numberList' in record and len(record['numberList']) >= 7:
            special_ball = record['numberList'][-1] 
            ball_number = int(special_ball['number'])
            entry = {
                'period': record['period'],
                'number': ball_number,
                'shengXiao': special_ball['shengXiao'],
                'color': NUM_TO_CATEGORY['æ³¢è‰²'].get(ball_number, 'æœªçŸ¥'),
                'wuXing': special_ball['wuXing']
            }
            special_history.append(entry)
    return special_history

def analyze_special_trend(special_history, weights):
    """
    V6 æ ¸å¿ƒç®—æ³•ï¼šå…¨åŸŸå·ç è¯„åˆ†ç³»ç»Ÿ + å…±æŒ¯æ•ˆåº”
    (Tier 1 Target: Special Number)
    """
    if not special_history:
        return None

    lookback = int(weights.get('special_lookback', 20))
    if lookback < 5: lookback = 5
    
    # æå–åŸºç¡€æƒé‡
    w_hot = weights.get('special_hot', 1.0)
    w_gap = weights.get('special_gap', 1.5)
    w_zodiac = weights.get('special_zodiac', 2.0)
    w_color = weights.get('special_color_weight', 1.0)
    w_tail = weights.get('special_tail_weight', 1.0)
    w_cold_protect = weights.get('special_cold_protect', 2.0)
    
    # æå– V6 æ–°å¢æƒé‡
    w_resonance = weights.get('special_resonance', 1.5) # å…±æŒ¯å€ç‡
    w_tail_cont = weights.get('special_tail_continuity', 1.0)

    recent_specials = special_history[:lookback]

    # --- 1. å¤šç»´ç»Ÿè®¡ ---
    # ç”Ÿè‚–
    zodiac_counts = Counter(r['shengXiao'] for r in recent_specials)
    zodiac_last_seen = {z: 100 for z in ZODIAC_MAP.keys()}
    for i, record in enumerate(special_history):
        z = record['shengXiao']
        if z in zodiac_last_seen and zodiac_last_seen[z] == 100:
            zodiac_last_seen[z] = i
    coldest_zodiac = max(zodiac_last_seen, key=zodiac_last_seen.get)

    # æ³¢è‰²
    color_counts = Counter(r['color'] for r in recent_specials)
    total_colors = sum(color_counts.values()) or 1
    color_weights = {c: (count / total_colors) for c, count in color_counts.items()}
    # æ‰¾å‡ºæœ€çƒ­æ³¢è‰²
    top_colors = {c for c, _ in color_counts.most_common(1)}

    # å°¾æ•°
    tails = [r['number'] % 10 for r in recent_specials]
    tail_counts = Counter(tails)
    total_tails = sum(tail_counts.values()) or 1
    tail_weights = {t: (count / total_tails) for t, count in tail_counts.items()}
    # æ‰¾å‡ºæœ€çƒ­å°¾æ•°
    top_tails = {t for t, _ in tail_counts.most_common(2)}

    # --- 2. åŸºç¡€è¯„åˆ† (ç”Ÿè‚–) ---
    zodiac_scores = {}
    for z in ZODIAC_MAP.keys():
        score = zodiac_counts.get(z, 0) * w_hot
        gap = zodiac_last_seen[z]
        if gap > 12: score += w_gap * 2
        elif gap == 1: score += w_gap * 0.5
        zodiac_scores[z] = score
    zodiac_scores[coldest_zodiac] += w_cold_protect
    
    # æ‰¾å‡ºå‰4åç”Ÿè‚–ä½œä¸ºâ€œå…±æŒ¯å€™é€‰åŒºâ€
    top_zodiacs_list = [z for z, _ in sorted(zodiac_scores.items(), key=lambda x: x[1], reverse=True)[:4]]

    # --- 3. å…¨åŸŸå·ç è¯„åˆ†ä¸å…±æŒ¯ (V6 æ ¸å¿ƒ) ---
    number_final_scores = Counter()

    for num in range(1, 50):
        z = NUM_TO_ZODIAC.get(num)
        c = NUM_TO_CATEGORY['æ³¢è‰²'].get(num)
        t = num % 10
        
        # åŸºç¡€åˆ†
        score = zodiac_scores.get(z, 0) * w_zodiac
        score += color_weights.get(c, 0) * w_color * 10
        score += tail_weights.get(t, 0) * w_tail * 10
        
        # V6 å…±æŒ¯æ£€æµ‹ (Resonance Check)
        resonance_level = 0
        if z in top_zodiacs_list: resonance_level += 1
        if c in top_colors: resonance_level += 1
        if t in top_tails: resonance_level += 1
        
        # å¦‚æœå‘ç”Ÿå…±æŒ¯ (è‡³å°‘2ä¸ªç»´åº¦å‘½ä¸­çƒ­é—¨)ï¼Œåº”ç”¨å…±æŒ¯å€ç‡
        if resonance_level >= 2:
            score *= w_resonance
            
        number_final_scores[num] = score

    # --- ç»“æœ ---
    recommended_numbers = [num for num, s in number_final_scores.most_common(8)]
    top_zodiacs_raw = sorted(zodiac_scores.items(), key=lambda x: x[1], reverse=True)[:4]
    
    # è·å–æœ€é«˜åˆ†å±æ€§ç”¨äºå±•ç¤º
    predicted_color = color_counts.most_common(1)[0][0] if color_counts else "æœªçŸ¥"
    predicted_tail = tail_counts.most_common(1)[0][0] if tail_counts else -1

    return {
        "top_zodiacs": top_zodiacs_raw,
        "predicted_color": predicted_color,
        "predicted_tail": predicted_tail,
        "recommended_numbers": recommended_numbers,
        "coldest_zodiac_defense": coldest_zodiac
    }

def advanced_analysis(history, weights):
    """
    V6 é€šç”¨åˆ†æï¼šåŒ…å« 3ä¸­3 (ä¸‰å…ƒé—­ç¯) å’Œ 2ä¸­2 (å…±ç°çŸ©é˜µ)
    (Tier 2 Target: Combos)
    """
    if not history:
        return None

    trend_lookback = int(weights.get('trend_lookback', 10))
    if trend_lookback <= 0: trend_lookback = 10

    # --- 1. åŸºç¡€è¶‹åŠ¿ ---
    category_trends = {cat: Counter() for cat in ALL_CATEGORIES}
    actual_lookback = min(trend_lookback, len(history))
    recent_history = history[:actual_lookback]
    for record in recent_history:
        numbers = {int(n['number']) for n in record.get('numberList', [])}
        for cat_name, cat_map in ALL_CATEGORIES.items():
            counts = Counter(NUM_TO_CATEGORY[cat_name].get(n) for n in numbers)
            category_trends[cat_name].update(counts)

    # --- 2. å·ç è¯„åˆ† ---
    number_scores = Counter()
    all_numbers = set(range(1, 50))
    number_freq = Counter(int(n['number']) for r in history for n in r.get('numberList', []))
    last_seen = {n: len(history) for n in all_numbers}
    for i, record in enumerate(history):
        numbers = {int(n['number']) for n in record.get('numberList', [])}
        for n in numbers:
            if n in last_seen and last_seen[n] == len(history):
                 last_seen[n] = i
    
    for num in all_numbers:
        number_scores[num] += number_freq.get(num, 0) * weights.get('hot_score', 0.5)
        number_scores[num] += last_seen.get(num, 0) * weights.get('cold_score', 0.8)

    for num in all_numbers:
        for cat_name, trend_counts in category_trends.items():
            num_cat = NUM_TO_CATEGORY[cat_name].get(num)
            if num_cat:
                score = trend_counts.get(num_cat, 0)
                number_scores[num] += score * weights.get('category_trend', 1.0)

    # --- 3. 2ä¸­2 ä¼˜åŒ– (äºŒå…ƒå…±ç°çŸ©é˜µ) ---
    pair_counts = Counter()
    for record in history:
        nums = sorted([int(n['number']) for n in record.get('numberList', [])[:-1]])
        for pair in combinations(nums, 2):
            pair_counts[pair] += 1

    # --- 4. 3ä¸­3 ä¼˜åŒ– (ä¸‰å…ƒé—­ç¯çŸ©é˜µ - V6 New) ---
    triplet_counts = Counter()
    for record in history:
        nums = sorted([int(n['number']) for n in record.get('numberList', [])[:-1]])
        for triplet in combinations(nums, 3):
            triplet_counts[triplet] += 1
            
    # --- 5. ç”Ÿæˆç»„åˆ ---
    top_20_numbers = [num for num, score in number_scores.most_common(20)]
    
    # ç”Ÿæˆ 2ä¸­2
    combo_2_scores = Counter()
    for combo in combinations(top_20_numbers, 2):
        sorted_combo = tuple(sorted(combo))
        score = sum(number_scores[n] for n in sorted_combo)
        
        colors = {NUM_TO_CATEGORY['æ³¢è‰²'].get(n) for n in sorted_combo}
        if len(colors) > 1:
            score *= weights.get('combo_2_diversity', 1.1)
            
        co_occurrence_bonus = pair_counts.get(sorted_combo, 0) * weights.get('co_occurrence_weight', 1.0)
        score += co_occurrence_bonus
        combo_2_scores[sorted_combo] = score

    # ç”Ÿæˆ 3ä¸­3
    combo_3_scores = Counter()
    for combo in combinations(top_20_numbers, 3):
        sorted_combo = tuple(sorted(combo))
        combo_sum = sum(combo)
        if not (40 <= combo_sum <= 110): continue 

        score = sum(number_scores[n] for n in combo)
        
        colors = {NUM_TO_CATEGORY['æ³¢è‰²'].get(n) for n in combo}
        elements = {NUM_TO_CATEGORY['äº”è¡Œ'].get(n) for n in combo}
        
        if len(colors) > 2:
            score *= weights.get('combo_3_color_diversity', 1.1)
        if len(elements) > 2:
            score *= weights.get('combo_3_element_diversity', 1.1)
        
        # V6: ä¸‰å…ƒé—­ç¯åŠ åˆ†
        triplet_bonus = triplet_counts.get(sorted_combo, 0) * weights.get('triplet_weight', 1.0) * 10
        score += triplet_bonus
            
        combo_3_scores[combo] = score

    # --- 6. ç»“æœæ‰“åŒ… ---
    zodiac_scores_general = Counter()
    for z, nums in ZODIAC_MAP.items():
        score = sum(number_scores[n] for n in nums)
        zodiac_scores_general[z] = score

    results_raw = {
        "zodiacs": [z for z, score in zodiac_scores_general.most_common(5)],
        "numbers": [n for n, score in number_scores.most_common(10)],
        "combos_2_in_2": [c for c, score in combo_2_scores.most_common(5)],
        "combos_3_in_3": [c for c, score in combo_3_scores.most_common(5)],
        "special_number": number_scores.most_common(1)[0][0] if number_scores else None,
        "special_zodiac": zodiac_scores_general.most_common(1)[0][0] if zodiac_scores_general else None
    }
    return results_raw


if __name__ == "__main__":
    import argparse
    import os

    parser = argparse.ArgumentParser(description="Run advanced analysis for Macau lottery.")
    parser.add_argument('--period', type=int, required=True, help='The lottery period to generate a prediction for.')
    parser.add_argument('--prediction_type', type=str, default='general', choices=['general', 'special'],
                        help='Type of prediction: "general" for all 7 numbers, "special" for the 7th number only.')
    args = parser.parse_args()
    
    prediction_period = args.period
    prediction_type = args.prediction_type
    
    RAW_PREDICTION_DIR = 'predictions'
    os.makedirs(RAW_PREDICTION_DIR, exist_ok=True)

    if prediction_type == 'general':
        STRATEGY_FILE = 'best_strategy_macau.json'
        FORMATTED_OUTPUT_FILE = 'macau_analysis_results.json'
        PREDICTION_HISTORY_FILE = 'macau_prediction_history.json'
        raw_prediction_filename = os.path.join(RAW_PREDICTION_DIR, f'macau_prediction_for_{prediction_period}.json')
        
        weights = {}
        try:
            with open(STRATEGY_FILE, 'r', encoding='utf-8') as f:
                weights = json.load(f)
            print(f"æˆåŠŸåŠ è½½æœ€ä¼˜ç­–ç•¥ '{STRATEGY_FILE}'ã€‚")
        except FileNotFoundError:
            print(f"æ³¨æ„: æœªæ‰¾åˆ°æœ€ä¼˜ç­–ç•¥æ–‡ä»¶ '{STRATEGY_FILE}'ã€‚å°†ä½¿ç”¨é»˜è®¤é€šç”¨ç­–ç•¥è¿›è¡Œåˆ†æã€‚")
        except Exception as e:
            print(f"é”™è¯¯: åŠ è½½ç­–ç•¥æ–‡ä»¶å¤±è´¥: {e}ã€‚å°†ä½¿ç”¨é»˜è®¤é€šç”¨ç­–ç•¥ã€‚")

        historical_data = load_data()
        if historical_data:
            print(f"ä¸ºæ¾³é—¨ç¬¬ {prediction_period} æœŸé€šç”¨åˆ†æåŠ è½½äº† {len(historical_data)} æ¡å†å²æ•°æ®ã€‚")
            analysis_results_raw = advanced_analysis(historical_data, weights)
            
            if analysis_results_raw:
                append_to_prediction_history(analysis_results_raw, prediction_period, PREDICTION_HISTORY_FILE)

                try:
                    with open(raw_prediction_filename, 'w', encoding='utf-8') as f:
                        json.dump(analysis_results_raw, f, ensure_ascii=False, indent=2)
                    print(f"åŸå§‹é€šç”¨é¢„æµ‹å­˜æ¡£å·²ä¿å­˜è‡³ {raw_prediction_filename}")
                except Exception as e:
                    print(f"é”™è¯¯: ä¿å­˜åŸå§‹é€šç”¨é¢„æµ‹è‡³ {raw_prediction_filename} å¤±è´¥ã€‚ {e}")

                results_formatted = {
                    "åˆ†ææœŸå·": prediction_period,
                    "çƒ­é—¨ç”Ÿè‚–": [f"{z}" for z in analysis_results_raw["zodiacs"]],
                    "çƒ­é—¨å·ç ": [f"å·ç  {n}" for n in analysis_results_raw["numbers"]],
                    "'2ä¸­2' ç»„åˆ": [f"ç»„åˆ {c}" for c in analysis_results_raw["combos_2_in_2"]],
                    "'3ä¸­3' ç»„åˆ": [f"ç»„åˆ {c}" for c in analysis_results_raw["combos_3_in_3"]]
                }
                try:
                    with open(FORMATTED_OUTPUT_FILE, 'w', encoding='utf-8') as f:
                        json.dump(results_formatted, f, ensure_ascii=False, indent=2)
                    print(f"æ ¼å¼åŒ–é€šç”¨åˆ†æç»“æœå·²ä¿å­˜è‡³ {FORMATTED_OUTPUT_FILE}")
                except Exception as e:
                    print(f"é”™è¯¯: ä¿å­˜æ ¼å¼åŒ–é€šç”¨ç»“æœè‡³ {FORMATTED_OUTPUT_FILE} å¤±è´¥ã€‚ {e}")
        else:
            print("æ²¡æœ‰è¶³å¤Ÿçš„å†å²æ•°æ®è¿›è¡Œé€šç”¨åˆ†æã€‚")

    elif prediction_type == 'special':
        STRATEGY_FILE = 'best_special_strategy_macau.json'
        FORMATTED_OUTPUT_FILE = 'macau_special_analysis_results.json'
        PREDICTION_HISTORY_FILE = 'macau_special_prediction_history.json'
        raw_prediction_filename = os.path.join(RAW_PREDICTION_DIR, f'macau_special_prediction_for_{prediction_period}.json')
        
        weights = {}
        try:
            with open(STRATEGY_FILE, 'r', encoding='utf-8') as f:
                weights = json.load(f)
            print(f"æˆåŠŸåŠ è½½æœ€ä¼˜ç‰¹ç ç­–ç•¥ '{STRATEGY_FILE}'ã€‚")
        except FileNotFoundError:
            print(f"æ³¨æ„: æœªæ‰¾åˆ°æœ€ä¼˜ç‰¹ç ç­–ç•¥æ–‡ä»¶ '{STRATEGY_FILE}'ã€‚å°†ä½¿ç”¨é»˜è®¤ç‰¹ç ç­–ç•¥è¿›è¡Œåˆ†æã€‚")
        except Exception as e:
            print(f"é”™è¯¯: åŠ è½½ç‰¹ç ç­–ç•¥æ–‡ä»¶å¤±è´¥: {e}ã€‚å°†ä½¿ç”¨é»˜è®¤ç‰¹ç ç­–ç•¥ã€‚")

        special_historical_data = load_special_number_data()
        if special_historical_data:
            print(f"ä¸ºæ¾³é—¨ç¬¬ {prediction_period} æœŸç‰¹ç åˆ†æåŠ è½½äº† {len(special_historical_data)} æ¡å†å²æ•°æ®ã€‚")
            analysis_results_raw = analyze_special_trend(special_historical_data, weights)
            
            if analysis_results_raw:
                append_to_prediction_history(analysis_results_raw, prediction_period, PREDICTION_HISTORY_FILE)

                try:
                    with open(raw_prediction_filename, 'w', encoding='utf-8') as f:
                        json.dump(analysis_results_raw, f, ensure_ascii=False, indent=2)
                    print(f"åŸå§‹ç‰¹ç é¢„æµ‹å­˜æ¡£å·²ä¿å­˜è‡³ {raw_prediction_filename}")
                except Exception as e:
                    print(f"é”™è¯¯: ä¿å­˜åŸå§‹ç‰¹ç é¢„æµ‹è‡³ {raw_prediction_filename} å¤±è´¥ã€‚ {e}")

                results_formatted = {
                    "åˆ†ææœŸå·": prediction_period,
                    "ç‰¹ç æ¨èç”Ÿè‚–": [f"{z[0]} (åˆ†æ•°: {z[1]:.2f})" for z in analysis_results_raw["top_zodiacs"]],
                    "é¢„æµ‹æ³¢è‰²": analysis_results_raw["predicted_color"],
                    "é¢„æµ‹å°¾æ•°": analysis_results_raw["predicted_tail"],
                    "ç»¼åˆæ¨èå·ç ": analysis_results_raw["recommended_numbers"],
                    "ç‰¹ç åˆ†æè¯´æ˜": "åŸºäºç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°ç»¼åˆåˆ†æï¼Œæ¨èåˆ†æ•°æœ€é«˜çš„å·ç ã€‚"
                }
                try:
                    with open(FORMATTED_OUTPUT_FILE, 'w', encoding='utf-8') as f:
                        json.dump(results_formatted, f, ensure_ascii=False, indent=2)
                    print(f"æ ¼å¼åŒ–ç‰¹ç åˆ†æç»“æœå·²ä¿å­˜è‡³ {FORMATTED_OUTPUT_FILE}")
                except Exception as e:
                    print(f"é”™è¯¯: ä¿å­˜æ ¼å¼åŒ–ç‰¹ç ç»“æœè‡³ {FORMATTED_OUTPUT_FILE} å¤±è´¥ã€‚ {e}")
        else:
            print("æ²¡æœ‰è¶³å¤Ÿçš„å†å²æ•°æ®è¿›è¡Œç‰¹ç åˆ†æã€‚")
```

### 5. ğŸ§  é¦™æ¸¯åˆ†ææ ¸å¿ƒï¼š`advanced_hk_analysis.py`

**å‡çº§ç‚¹**ï¼šåŒä¸Šï¼ŒåŒæ­¥ V6 ç®—æ³•ã€‚

Python

```
import json
from collections import Counter
from itertools import combinations
import os

# --- Helper Functions for JSON ---
def load_json_safe(file_path, default_value=None):
    if default_value is None:
        default_value = []
    if os.path.exists(file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError):
            return default_value
    return default_value

def save_json_safe(data, file_path):
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return True
    except IOError as e:
        print(f"Error saving JSON to {file_path}: {e}")
        return False

def append_to_prediction_history(prediction_data, prediction_period, history_file):
    history = load_json_safe(history_file)
    if not any(entry.get('period') == prediction_period for entry in history):
        prediction_data_with_period = prediction_data.copy()
        prediction_data_with_period['period'] = prediction_period
        history.insert(0, prediction_data_with_period)
        save_json_safe(history, history_file)
        print(f"é¢„æµ‹ç»“æœå·²è¿½åŠ åˆ°å†å²æ–‡ä»¶: {history_file}")
    else:
        print(f"æœŸå· {prediction_period} çš„é¢„æµ‹å·²å­˜åœ¨äºå†å²æ–‡ä»¶ {history_file} ä¸­ï¼Œè·³è¿‡è¿½åŠ ã€‚")

# --- RULE DEFINITIONS ---
ZODIAC_MAP = {
    'é¼ ': {6, 18, 30, 42}, 'ç‰›': {5, 17, 29, 41}, 'è™': {4, 16, 28, 40},
    'å…”': {3, 15, 27, 39}, 'é¾™': {2, 14, 26, 38}, 'è›‡': {1, 13, 25, 37, 49},
    'é©¬': {12, 24, 36, 48}, 'ç¾Š': {11, 23, 35, 47}, 'çŒ´': {10, 22, 34, 46},
    'é¸¡': {9, 21, 33, 45}, 'ç‹—': {8, 20, 32, 44}, 'çŒª': {7, 19, 31, 43}
}

COLOR_MAP = {
    'ç»¿æ³¢': {5, 6, 11, 16, 17, 21, 22, 27, 28, 32, 33, 38, 39, 43, 44, 49},
    'çº¢æ³¢': {1, 2, 7, 8, 12, 13, 18, 19, 23, 24, 29, 30, 34, 35, 40, 45, 46},
    'è“æ³¢': {3, 4, 9, 10, 14, 15, 20, 25, 26, 31, 36, 37, 41, 42, 47, 48}
}

ELEMENT_MAP = {
    'é‡‘': {3, 4, 11, 12, 25, 26, 33, 34, 41, 42},
    'æœ¨': {7, 8, 15, 16, 23, 24, 37, 38, 45, 46},
    'æ°´': {13, 14, 21, 22, 29, 30, 43, 44},
    'ç«': {1, 2, 9, 10, 17, 18, 31, 32, 39, 40, 47, 48},
    'åœŸ': {5, 6, 19, 20, 27, 28, 35, 36, 49}
}

# Binary classifications & Categories
HEAVEN_EARTH_MAP = {'å¤©è‚–': {'å…”', 'ç‰›', 'é©¬', 'çŒ´', 'çŒª', 'é¾™'}, 'åœ°è‚–': {'é¼ ', 'è™', 'è›‡', 'ç¾Š', 'é¸¡', 'ç‹—'}}
YIN_YANG_MAP = {'é˜³è‚–': {'é¼ ', 'è™', 'é¾™', 'é©¬', 'çŒ´', 'ç‹—'}, 'é˜´è‚–': {'ç‰›', 'å…”', 'è›‡', 'ç¾Š', 'é¸¡', 'çŒª'}}
MALE_FEMALE_MAP = {'ç”·è‚–': {'é¼ ', 'ç‰›', 'è™', 'é¾™', 'é©¬', 'çŒ´', 'ç‹—'}, 'å¥³è‚–': {'å…”', 'è›‡', 'ç¾Š', 'é¸¡', 'çŒª'}}
AUSPICIOUS_MAP = {'å‰è‚–': {'å…”', 'é¾™', 'è›‡', 'é©¬', 'ç¾Š', 'é¸¡'}, 'å‡¶è‚–': {'é¼ ', 'ç‰›', 'è™', 'çŒ´', 'ç‹—', 'çŒª'}}
SEASON_MAP = {
    'æ˜¥å¤©': {'è™', 'å…”', 'é¾™'}, 'å¤å¤©': {'è›‡', 'é©¬', 'ç¾Š'},
    'ç§‹å¤©': {'çŒ´', 'é¸¡', 'ç‹—'}, 'å†¬å¤©': {'é¼ ', 'çŒª', 'ç‰›'}
}

ALL_CATEGORIES = {
    "æ³¢è‰²": COLOR_MAP, "äº”è¡Œ": ELEMENT_MAP, "å¤©åœ°": HEAVEN_EARTH_MAP,
    "é˜´é˜³": YIN_YANG_MAP, "ç”·å¥³": MALE_FEMALE_MAP, "å‰å‡¶": AUSPICIOUS_MAP, "å­£èŠ‚": SEASON_MAP
}

# Reverse mapping
NUM_TO_ZODIAC = {num: z for z, nums in ZODIAC_MAP.items() for num in nums}
NUM_TO_CATEGORY = {cat_name: {num: k for k, v in cat_map.items() for num in v}
                   for cat_name, cat_map in {**{"æ³¢è‰²": COLOR_MAP, "äº”è¡Œ": ELEMENT_MAP}}.items()}

for cat_name, cat_map in ALL_CATEGORIES.items():
    if cat_name not in NUM_TO_CATEGORY:
        NUM_TO_CATEGORY[cat_name] = {
            num: k for k, z_set in cat_map.items() for z in z_set for num in ZODIAC_MAP[z]
        }

def load_data():
    """Loads and combines all HK lottery data."""
    all_records = {}
    try:
        with open('HK2025_lottery_data_complete.json', 'r', encoding='utf-8') as f:
            new_data = json.load(f).get('totalRecords', [])
        for record in new_data:
            if 'period' in record:
                all_records[record['period']] = record
    except FileNotFoundError:
        print("é”™è¯¯: HK2025_lottery_data_complete.json æœªæ‰¾åˆ°ã€‚")
        return []
    sorted_periods = sorted(all_records.keys(), key=lambda p: int(p), reverse=True)
    return [all_records[p] for p in sorted_periods]

def load_special_number_data(file_path='HK2025_lottery_data_complete.json'):
    import json
    import os
    if not os.path.exists(file_path): return []
    with open(file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    special_history = []
    records = data.get('totalRecords', [])
    records.sort(key=lambda x: int(x['period']), reverse=True)
    for record in records:
        if 'numberList' in record and len(record['numberList']) >= 7:
            special_ball = record['numberList'][-1] 
            ball_number = int(special_ball['number'])
            entry = {
                'period': record['period'],
                'number': ball_number,
                'shengXiao': special_ball['shengXiao'],
                'color': NUM_TO_CATEGORY['æ³¢è‰²'].get(ball_number, 'æœªçŸ¥'),
                'wuXing': special_ball['wuXing']
            }
            special_history.append(entry)
    return special_history

def analyze_special_trend(special_history, weights):
    """
    V6 æ ¸å¿ƒç®—æ³•ï¼šå…¨åŸŸå·ç è¯„åˆ†ç³»ç»Ÿ + å…±æŒ¯æ•ˆåº”
    (Tier 1 Target: Special Number)
    """
    if not special_history:
        return None

    lookback = int(weights.get('special_lookback', 20))
    if lookback < 5: lookback = 5
    
    # æå–åŸºç¡€æƒé‡
    w_hot = weights.get('special_hot', 1.0)
    w_gap = weights.get('special_gap', 1.5)
    w_zodiac = weights.get('special_zodiac', 2.0)
    w_color = weights.get('special_color_weight', 1.0)
    w_tail = weights.get('special_tail_weight', 1.0)
    w_cold_protect = weights.get('special_cold_protect', 2.0)
    
    # æå– V6 æ–°å¢æƒé‡
    w_resonance = weights.get('special_resonance', 1.5) # å…±æŒ¯å€ç‡
    w_tail_cont = weights.get('special_tail_continuity', 1.0)

    recent_specials = special_history[:lookback]

    # --- 1. å¤šç»´ç»Ÿè®¡ ---
    # ç”Ÿè‚–
    zodiac_counts = Counter(r['shengXiao'] for r in recent_specials)
    zodiac_last_seen = {z: 100 for z in ZODIAC_MAP.keys()}
    for i, record in enumerate(special_history):
        z = record['shengXiao']
        if z in zodiac_last_seen and zodiac_last_seen[z] == 100:
            zodiac_last_seen[z] = i
    coldest_zodiac = max(zodiac_last_seen, key=zodiac_last_seen.get)

    # æ³¢è‰²
    color_counts = Counter(r['color'] for r in recent_specials)
    total_colors = sum(color_counts.values()) or 1
    color_weights = {c: (count / total_colors) for c, count in color_counts.items()}
    # æ‰¾å‡ºæœ€çƒ­æ³¢è‰²
    top_colors = {c for c, _ in color_counts.most_common(1)}

    # å°¾æ•°
    tails = [r['number'] % 10 for r in recent_specials]
    tail_counts = Counter(tails)
    total_tails = sum(tail_counts.values()) or 1
    tail_weights = {t: (count / total_tails) for t, count in tail_counts.items()}
    # æ‰¾å‡ºæœ€çƒ­å°¾æ•°
    top_tails = {t for t, _ in tail_counts.most_common(2)}

    # --- 2. åŸºç¡€è¯„åˆ† (ç”Ÿè‚–) ---
    zodiac_scores = {}
    for z in ZODIAC_MAP.keys():
        score = zodiac_counts.get(z, 0) * w_hot
        gap = zodiac_last_seen[z]
        if gap > 12: score += w_gap * 2
        elif gap == 1: score += w_gap * 0.5
        zodiac_scores[z] = score
    zodiac_scores[coldest_zodiac] += w_cold_protect
    
    # æ‰¾å‡ºå‰4åç”Ÿè‚–ä½œä¸ºâ€œå…±æŒ¯å€™é€‰åŒºâ€
    top_zodiacs_list = [z for z, _ in sorted(zodiac_scores.items(), key=lambda x: x[1], reverse=True)[:4]]

    # --- 3. å…¨åŸŸå·ç è¯„åˆ†ä¸å…±æŒ¯ (V6 æ ¸å¿ƒ) ---
    number_final_scores = Counter()

    for num in range(1, 50):
        z = NUM_TO_ZODIAC.get(num)
        c = NUM_TO_CATEGORY['æ³¢è‰²'].get(num)
        t = num % 10
        
        # åŸºç¡€åˆ†
        score = zodiac_scores.get(z, 0) * w_zodiac
        score += color_weights.get(c, 0) * w_color * 10
        score += tail_weights.get(t, 0) * w_tail * 10
        
        # V6 å…±æŒ¯æ£€æµ‹ (Resonance Check)
        resonance_level = 0
        if z in top_zodiacs_list: resonance_level += 1
        if c in top_colors: resonance_level += 1
        if t in top_tails: resonance_level += 1
        
        # å¦‚æœå‘ç”Ÿå…±æŒ¯ (è‡³å°‘2ä¸ªç»´åº¦å‘½ä¸­çƒ­é—¨)ï¼Œåº”ç”¨å…±æŒ¯å€ç‡
        if resonance_level >= 2:
            score *= w_resonance
            
        number_final_scores[num] = score

    # --- ç»“æœ ---
    recommended_numbers = [num for num, s in number_final_scores.most_common(8)]
    top_zodiacs_raw = sorted(zodiac_scores.items(), key=lambda x: x[1], reverse=True)[:4]
    
    # è·å–æœ€é«˜åˆ†å±æ€§ç”¨äºå±•ç¤º
    predicted_color = color_counts.most_common(1)[0][0] if color_counts else "æœªçŸ¥"
    predicted_tail = tail_counts.most_common(1)[0][0] if tail_counts else -1

    return {
        "top_zodiacs": top_zodiacs_raw,
        "predicted_color": predicted_color,
        "predicted_tail": predicted_tail,
        "recommended_numbers": recommended_numbers,
        "coldest_zodiac_defense": coldest_zodiac
    }

def advanced_analysis(history, weights):
    """
    V6 é€šç”¨åˆ†æï¼šåŒ…å« 3ä¸­3 (ä¸‰å…ƒé—­ç¯) å’Œ 2ä¸­2 (å…±ç°çŸ©é˜µ)
    (Tier 2 Target: Combos)
    """
    if not history:
        return None

    trend_lookback = int(weights.get('trend_lookback', 10))
    if trend_lookback <= 0: trend_lookback = 10

    # --- 1. åŸºç¡€è¶‹åŠ¿ ---
    category_trends = {cat: Counter() for cat in ALL_CATEGORIES}
    actual_lookback = min(trend_lookback, len(history))
    recent_history = history[:actual_lookback]
    for record in recent_history:
        numbers = {int(n['number']) for n in record.get('numberList', [])}
        for cat_name, cat_map in ALL_CATEGORIES.items():
            counts = Counter(NUM_TO_CATEGORY[cat_name].get(n) for n in numbers)
            category_trends[cat_name].update(counts)

    # --- 2. å·ç è¯„åˆ† ---
    number_scores = Counter()
    all_numbers = set(range(1, 50))
    number_freq = Counter(int(n['number']) for r in history for n in r.get('numberList', []))
    last_seen = {n: len(history) for n in all_numbers}
    for i, record in enumerate(history):
        numbers = {int(n['number']) for n in record.get('numberList', [])}
        for n in numbers:
            if n in last_seen and last_seen[n] == len(history):
                 last_seen[n] = i
    
    for num in all_numbers:
        number_scores[num] += number_freq.get(num, 0) * weights.get('hot_score', 0.5)
        number_scores[num] += last_seen.get(num, 0) * weights.get('cold_score', 0.8)

    for num in all_numbers:
        for cat_name, trend_counts in category_trends.items():
            num_cat = NUM_TO_CATEGORY[cat_name].get(num)
            if num_cat:
                score = trend_counts.get(num_cat, 0)
                number_scores[num] += score * weights.get('category_trend', 1.0)

    # --- 3. 2ä¸­2 ä¼˜åŒ– (äºŒå…ƒå…±ç°çŸ©é˜µ) ---
    pair_counts = Counter()
    for record in history:
        nums = sorted([int(n['number']) for n in record.get('numberList', [])[:-1]])
        for pair in combinations(nums, 2):
            pair_counts[pair] += 1

    # --- 4. 3ä¸­3 ä¼˜åŒ– (ä¸‰å…ƒé—­ç¯çŸ©é˜µ - V6 New) ---
    triplet_counts = Counter()
    for record in history:
        nums = sorted([int(n['number']) for n in record.get('numberList', [])[:-1]])
        for triplet in combinations(nums, 3):
            triplet_counts[triplet] += 1
            
    # --- 5. ç”Ÿæˆç»„åˆ ---
    top_20_numbers = [num for num, score in number_scores.most_common(20)]
    
    # ç”Ÿæˆ 2ä¸­2
    combo_2_scores = Counter()
    for combo in combinations(top_20_numbers, 2):
        sorted_combo = tuple(sorted(combo))
        score = sum(number_scores[n] for n in sorted_combo)
        
        colors = {NUM_TO_CATEGORY['æ³¢è‰²'].get(n) for n in sorted_combo}
        if len(colors) > 1:
            score *= weights.get('combo_2_diversity', 1.1)
            
        co_occurrence_bonus = pair_counts.get(sorted_combo, 0) * weights.get('co_occurrence_weight', 1.0)
        score += co_occurrence_bonus
        combo_2_scores[sorted_combo] = score

    # ç”Ÿæˆ 3ä¸­3
    combo_3_scores = Counter()
    for combo in combinations(top_20_numbers, 3):
        sorted_combo = tuple(sorted(combo))
        combo_sum = sum(combo)
        if not (40 <= combo_sum <= 110): continue 

        score = sum(number_scores[n] for n in combo)
        
        colors = {NUM_TO_CATEGORY['æ³¢è‰²'].get(n) for n in combo}
        elements = {NUM_TO_CATEGORY['äº”è¡Œ'].get(n) for n in combo}
        
        if len(colors) > 2:
            score *= weights.get('combo_3_color_diversity', 1.1)
        if len(elements) > 2:
            score *= weights.get('combo_3_element_diversity', 1.1)
        
        # V6: ä¸‰å…ƒé—­ç¯åŠ åˆ†
        triplet_bonus = triplet_counts.get(sorted_combo, 0) * weights.get('triplet_weight', 1.0) * 10
        score += triplet_bonus
            
        combo_3_scores[combo] = score

    # --- 6. ç»“æœæ‰“åŒ… ---
    zodiac_scores_general = Counter()
    for z, nums in ZODIAC_MAP.items():
        score = sum(number_scores[n] for n in nums)
        zodiac_scores_general[z] = score

    results_raw = {
        "zodiacs": [z for z, score in zodiac_scores_general.most_common(5)],
        "numbers": [n for n, score in number_scores.most_common(10)],
        "combos_2_in_2": [c for c, score in combo_2_scores.most_common(5)],
        "combos_3_in_3": [c for c, score in combo_3_scores.most_common(5)],
        "special_number": number_scores.most_common(1)[0][0] if number_scores else None,
        "special_zodiac": zodiac_scores_general.most_common(1)[0][0] if zodiac_scores_general else None
    }
    return results_raw


if __name__ == "__main__":
    import argparse
    import os

    parser = argparse.ArgumentParser(description="Run advanced analysis for HK lottery.")
    parser.add_argument('--period', type=int, required=True, help='The lottery period to generate a prediction for.')
    parser.add_argument('--prediction_type', type=str, default='general', choices=['general', 'special'],
                        help='Type of prediction: "general" for all 7 numbers, "special" for the 7th number only.')
    args = parser.parse_args()
    
    prediction_period = args.period
    prediction_type = args.prediction_type
    
    RAW_PREDICTION_DIR = 'predictions'
    os.makedirs(RAW_PREDICTION_DIR, exist_ok=True)

    if prediction_type == 'general':
        STRATEGY_FILE = 'best_strategy_hk.json'
        FORMATTED_OUTPUT_FILE = 'hk_analysis_results.json'
        PREDICTION_HISTORY_FILE = 'hk_prediction_history.json'
        raw_prediction_filename = os.path.join(RAW_PREDICTION_DIR, f'hk_prediction_for_{prediction_period}.json')
        
        weights = {}
        try:
            with open(STRATEGY_FILE, 'r', encoding='utf-8') as f:
                weights = json.load(f)
            print(f"æˆåŠŸåŠ è½½æœ€ä¼˜ç­–ç•¥ '{STRATEGY_FILE}'ã€‚")
        except FileNotFoundError:
            print(f"æ³¨æ„: æœªæ‰¾åˆ°æœ€ä¼˜ç­–ç•¥æ–‡ä»¶ '{STRATEGY_FILE}'ã€‚å°†ä½¿ç”¨é»˜è®¤é€šç”¨ç­–ç•¥è¿›è¡Œåˆ†æã€‚")
        except Exception as e:
            print(f"é”™è¯¯: åŠ è½½ç­–ç•¥æ–‡ä»¶å¤±è´¥: {e}ã€‚å°†ä½¿ç”¨é»˜è®¤é€šç”¨ç­–ç•¥ã€‚")

        historical_data = load_data()
        if historical_data:
            print(f"ä¸ºé¦™æ¸¯ç¬¬ {prediction_period} æœŸé€šç”¨åˆ†æåŠ è½½äº† {len(historical_data)} æ¡å†å²æ•°æ®ã€‚")
            analysis_results_raw = advanced_analysis(historical_data, weights)
            
            if analysis_results_raw:
                append_to_prediction_history(analysis_results_raw, prediction_period, PREDICTION_HISTORY_FILE)

                try:
                    with open(raw_prediction_filename, 'w', encoding='utf-8') as f:
                        json.dump(analysis_results_raw, f, ensure_ascii=False, indent=2)
                    print(f"åŸå§‹é€šç”¨é¢„æµ‹å­˜æ¡£å·²ä¿å­˜è‡³ {raw_prediction_filename}")
                except Exception as e:
                    print(f"é”™è¯¯: ä¿å­˜åŸå§‹é€šç”¨é¢„æµ‹è‡³ {raw_prediction_filename} å¤±è´¥ã€‚ {e}")

                results_formatted = {
                    "åˆ†ææœŸå·": prediction_period,
                    "çƒ­é—¨ç”Ÿè‚–": [f"{z}" for z in analysis_results_raw["zodiacs"]],
                    "çƒ­é—¨å·ç ": [f"å·ç  {n}" for n in analysis_results_raw["numbers"]],
                    "'2ä¸­2' ç»„åˆ": [f"ç»„åˆ {c}" for c in analysis_results_raw["combos_2_in_2"]],
                    "'3ä¸­3' ç»„åˆ": [f"ç»„åˆ {c}" for c in analysis_results_raw["combos_3_in_3"]]
                }
                try:
                    with open(FORMATTED_OUTPUT_FILE, 'w', encoding='utf-8') as f:
                        json.dump(results_formatted, f, ensure_ascii=False, indent=2)
                    print(f"æ ¼å¼åŒ–é€šç”¨åˆ†æç»“æœå·²ä¿å­˜è‡³ {FORMATTED_OUTPUT_FILE}")
                except Exception as e:
                    print(f"é”™è¯¯: ä¿å­˜æ ¼å¼åŒ–é€šç”¨ç»“æœè‡³ {FORMATTED_OUTPUT_FILE} å¤±è´¥ã€‚ {e}")
        else:
            print("æ²¡æœ‰è¶³å¤Ÿçš„å†å²æ•°æ®è¿›è¡Œé€šç”¨åˆ†æã€‚")

    elif prediction_type == 'special':
        STRATEGY_FILE = 'best_special_strategy_hk.json'
        FORMATTED_OUTPUT_FILE = 'hk_special_analysis_results.json'
        PREDICTION_HISTORY_FILE = 'hk_special_prediction_history.json'
        raw_prediction_filename = os.path.join(RAW_PREDICTION_DIR, f'hk_special_prediction_for_{prediction_period}.json')
        
        weights = {}
        try:
            with open(STRATEGY_FILE, 'r', encoding='utf-8') as f:
                weights = json.load(f)
            print(f"æˆåŠŸåŠ è½½æœ€ä¼˜ç‰¹ç ç­–ç•¥ '{STRATEGY_FILE}'ã€‚")
        except FileNotFoundError:
            print(f"æ³¨æ„: æœªæ‰¾åˆ°æœ€ä¼˜ç‰¹ç ç­–ç•¥æ–‡ä»¶ '{STRATEGY_FILE}'ã€‚å°†ä½¿ç”¨é»˜è®¤ç‰¹ç ç­–ç•¥è¿›è¡Œåˆ†æã€‚")
        except Exception as e:
            print(f"é”™è¯¯: åŠ è½½ç‰¹ç ç­–ç•¥æ–‡ä»¶å¤±è´¥: {e}ã€‚å°†ä½¿ç”¨é»˜è®¤ç‰¹ç ç­–ç•¥ã€‚")

        special_historical_data = load_special_number_data()
        if special_historical_data:
            print(f"ä¸ºé¦™æ¸¯ç¬¬ {prediction_period} æœŸç‰¹ç åˆ†æåŠ è½½äº† {len(special_historical_data)} æ¡å†å²æ•°æ®ã€‚")
            analysis_results_raw = analyze_special_trend(special_historical_data, weights)
            
            if analysis_results_raw:
                append_to_prediction_history(analysis_results_raw, prediction_period, PREDICTION_HISTORY_FILE)

                try:
                    with open(raw_prediction_filename, 'w', encoding='utf-8') as f:
                        json.dump(analysis_results_raw, f, ensure_ascii=False, indent=2)
                    print(f"åŸå§‹ç‰¹ç é¢„æµ‹å­˜æ¡£å·²ä¿å­˜è‡³ {raw_prediction_filename}")
                except Exception as e:
                    print(f"é”™è¯¯: ä¿å­˜åŸå§‹ç‰¹ç é¢„æµ‹è‡³ {raw_prediction_filename} å¤±è´¥ã€‚ {e}")

                results_formatted = {
                    "åˆ†ææœŸå·": prediction_period,
                    "ç‰¹ç æ¨èç”Ÿè‚–": [f"{z[0]} (åˆ†æ•°: {z[1]:.2f})" for z in analysis_results_raw["top_zodiacs"]],
                    "é¢„æµ‹æ³¢è‰²": analysis_results_raw["predicted_color"],
                    "é¢„æµ‹å°¾æ•°": analysis_results_raw["predicted_tail"],
                    "ç»¼åˆæ¨èå·ç ": analysis_results_raw["recommended_numbers"],
                    "ç‰¹ç åˆ†æè¯´æ˜": "åŸºäºç”Ÿè‚–ã€æ³¢è‰²ã€å°¾æ•°ç»¼åˆåˆ†æï¼Œæ¨èåˆ†æ•°æœ€é«˜çš„å·ç ã€‚"
                }
                try:
                    with open(FORMATTED_OUTPUT_FILE, 'w', encoding='utf-8') as f:
                        json.dump(results_formatted, f, ensure_ascii=False, indent=2)
                    print(f"æ ¼å¼åŒ–ç‰¹ç åˆ†æç»“æœå·²ä¿å­˜è‡³ {FORMATTED_OUTPUT_FILE}")
                except Exception as e:
                    print(f"é”™è¯¯: ä¿å­˜æ ¼å¼åŒ–ç‰¹ç ç»“æœè‡³ {FORMATTED_OUTPUT_FILE} å¤±è´¥ã€‚ {e}")
        else:
            print("æ²¡æœ‰è¶³å¤Ÿçš„å†å²æ•°æ®è¿›è¡Œç‰¹ç åˆ†æã€‚")
```